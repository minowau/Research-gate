import { Actor, HttpAgent, Identity } from '@dfinity/agent';
import { AuthClient } from '@dfinity/auth-client';
import { Principal } from '@dfinity/principal';

// Import the generated declarations
// These would be auto-generated by dfx generate
import { 
    paperStorage,
    createActor as createPaperStorageActor,
} from '../declarations/paperStorage';
import { 
    daoSystem,
    createActor as createDAOSystemActor,
} from '../declarations/daoSystem';
import { 
    aiChatbot,
    createActor as createAIChatbotActor,
} from '../declarations/aiChatbot';

// Types
export interface CanisterActors {
    paperStorage: typeof paperStorage;
    daoSystem: typeof daoSystem;
    aiChatbot: typeof aiChatbot;
}

export interface DeResNetAPI {
    actors: CanisterActors;
    agent: HttpAgent;
    authClient: AuthClient;
    identity: Identity | null;
    isAuthenticated: boolean;
}

// Configuration
const isDevelopment = process.env.NODE_ENV === 'development';
const host = isDevelopment ? 'http://localhost:4943' : 'https://ic0.app';

// Canister IDs - these would be set by environment variables in production
const CANISTER_IDS = {
    paperStorage: process.env.CANISTER_ID_PAPERSTORAGE || 'rdmx6-jaaaa-aaaaa-aaadq-cai',
    daoSystem: process.env.CANISTER_ID_DAOSYSTEM || 'rrkah-fqaaa-aaaaa-aaaaq-cai',
    aiChatbot: process.env.CANISTER_ID_AICHATBOT || 'rno2w-sqaaa-aaaaa-aaacq-cai',
};

class DeResNetService {
    private authClient: AuthClient | null = null;
    private agent: HttpAgent | null = null;
    private actors: CanisterActors | null = null;
    private identity: Identity | null = null;
    private isAuthenticated: boolean = false;

    async initialize(): Promise<DeResNetAPI> {
        // Initialize auth client
        this.authClient = await AuthClient.create();
        
        // Check if user is already authenticated
        this.isAuthenticated = await this.authClient.isAuthenticated();
        
        if (this.isAuthenticated) {
            this.identity = this.authClient.getIdentity();
        }

        // Create HTTP agent
        this.agent = new HttpAgent({
            host,
            identity: this.identity,
        });

        // In development, fetch root key
        if (isDevelopment) {
            await this.agent.fetchRootKey();
        }

        // Create actors
        this.actors = {
            paperStorage: createPaperStorageActor(CANISTER_IDS.paperStorage, {
                agent: this.agent,
            }),
            daoSystem: createDAOSystemActor(CANISTER_IDS.daoSystem, {
                agent: this.agent,
            }),
            aiChatbot: createAIChatbotActor(CANISTER_IDS.aiChatbot, {
                agent: this.agent,
            }),
        };

        return {
            actors: this.actors,
            agent: this.agent,
            authClient: this.authClient,
            identity: this.identity,
            isAuthenticated: this.isAuthenticated,
        };
    }

    async login(): Promise<boolean> {
        if (!this.authClient) {
            throw new Error('Auth client not initialized');
        }

        return new Promise((resolve) => {
            this.authClient!.login({
                identityProvider: isDevelopment 
                    ? `http://localhost:4943/?canisterId=${process.env.CANISTER_ID_INTERNET_IDENTITY}`
                    : 'https://identity.ic0.app',
                onSuccess: async () => {
                    this.isAuthenticated = true;
                    this.identity = this.authClient!.getIdentity();
                    
                    // Update agent with new identity
                    if (this.agent) {
                        this.agent.replaceIdentity(this.identity);
                    }

                    // Recreate actors with authenticated agent
                    await this.updateActors();
                    resolve(true);
                },
                onError: (error) => {
                    console.error('Login failed:', error);
                    resolve(false);
                },
            });
        });
    }

    async logout(): Promise<void> {
        if (!this.authClient) {
            throw new Error('Auth client not initialized');
        }

        await this.authClient.logout();
        this.isAuthenticated = false;
        this.identity = null;

        // Update agent to anonymous identity
        if (this.agent) {
            this.agent.replaceIdentity(null);
        }

        // Recreate actors with anonymous agent
        await this.updateActors();
    }

    private async updateActors(): Promise<void> {
        if (!this.agent) return;

        this.actors = {
            paperStorage: createPaperStorageActor(CANISTER_IDS.paperStorage, {
                agent: this.agent,
            }),
            daoSystem: createDAOSystemActor(CANISTER_IDS.daoSystem, {
                agent: this.agent,
            }),
            aiChatbot: createAIChatbotActor(CANISTER_IDS.aiChatbot, {
                agent: this.agent,
            }),
        };
    }

    getActors(): CanisterActors {
        if (!this.actors) {
            throw new Error('Service not initialized');
        }
        return this.actors;
    }

    getIdentity(): Identity | null {
        return this.identity;
    }

    getIsAuthenticated(): boolean {
        return this.isAuthenticated;
    }

    getPrincipal(): Principal | null {
        return this.identity?.getPrincipal() || null;
    }
}

// Export singleton instance
export const deresnetService = new DeResNetService();

// Utility functions for common operations
export class DeResNetUtils {
    static async handleResult<T>(
        operation: () => Promise<{ ok: T } | { err: any }>
    ): Promise<T> {
        try {
            const result = await operation();
            if ('ok' in result) {
                return result.ok;
            } else {
                throw new Error(result.err);
            }
        } catch (error) {
            console.error('Canister operation failed:', error);
            throw error;
        }
    }

    static formatTimestamp(timestamp: bigint): Date {
        // Convert nanoseconds to milliseconds
        return new Date(Number(timestamp / 1000000n));
    }

    static timestampToNanos(date: Date): bigint {
        // Convert milliseconds to nanoseconds
        return BigInt(date.getTime() * 1000000);
    }

    static formatTokenAmount(amount: bigint): string {
        return amount.toLocaleString();
    }

    static parseTokenAmount(amount: string): bigint {
        return BigInt(parseInt(amount.replace(/,/g, '')));
    }
}

// Paper Storage API wrapper
export class PaperStorageAPI {
    constructor(private actors: CanisterActors) {}

    async registerUser(profile: {
        name: string;
        email: string;
        institution: string;
        avatar?: string;
    }) {
        return DeResNetUtils.handleResult(() =>
            this.actors.paperStorage.registerUser({
                name: profile.name,
                email: profile.email,
                institution: profile.institution,
                avatar: profile.avatar ? [profile.avatar] : [],
            })
        );
    }

    async getUser() {
        return DeResNetUtils.handleResult(() =>
            this.actors.paperStorage.getUser()
        );
    }

    async submitPaper(submission: {
        title: string;
        abstract: string;
        authors: string[];
        institution: string;
        tags: string[];
        doi?: string;
        fileData: Uint8Array;
        category: string;
    }) {
        return DeResNetUtils.handleResult(() =>
            this.actors.paperStorage.submitPaper({
                title: submission.title,
                abstract: submission.abstract,
                authors: submission.authors,
                institution: submission.institution,
                tags: submission.tags,
                doi: submission.doi ? [submission.doi] : [],
                fileData: submission.fileData,
                category: submission.category,
            })
        );
    }

    async getAllPapers(page: number = 0, limit: number = 10) {
        return this.actors.paperStorage.getAllPapers({ page, limit });
    }

    async searchPapers(
        query: {
            keywords?: string;
            tags?: string[];
            authors?: string[];
            institution?: string;
            dateFrom?: Date;
            dateTo?: Date;
            status?: 'published' | 'under_review' | 'draft';
        },
        page: number = 0,
        limit: number = 10
    ) {
        const searchQuery = {
            keywords: query.keywords ? [query.keywords] : [],
            tags: query.tags ? [query.tags] : [],
            authors: query.authors ? [query.authors] : [],
            institution: query.institution ? [query.institution] : [],
            dateFrom: query.dateFrom ? [DeResNetUtils.timestampToNanos(query.dateFrom)] : [],
            dateTo: query.dateTo ? [DeResNetUtils.timestampToNanos(query.dateTo)] : [],
            status: query.status ? [{ [query.status]: null }] : [],
        };

        return this.actors.paperStorage.searchPapers(searchQuery, { page, limit });
    }

    async getPaper(paperId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.paperStorage.getPaper(paperId)
        );
    }

    async submitReview(paperId: string, score: number, comments: string, isPublic: boolean) {
        return DeResNetUtils.handleResult(() =>
            this.actors.paperStorage.submitReview(paperId, score, comments, isPublic)
        );
    }

    async getReviewsForPaper(paperId: string) {
        return this.actors.paperStorage.getReviewsForPaper(paperId);
    }

    async incrementDownloads(paperId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.paperStorage.incrementDownloads(paperId)
        );
    }

    async getPaperStats() {
        return this.actors.paperStorage.getPaperStats();
    }

    async getTrendingPapers(limit: number = 10) {
        return this.actors.paperStorage.getTrendingPapers(limit);
    }

    async getPopularTags(limit: number = 20) {
        return this.actors.paperStorage.getPopularTags(limit);
    }
}

// DAO System API wrapper
export class DAOSystemAPI {
    constructor(private actors: CanisterActors) {}

    async initializeTokens() {
        return DeResNetUtils.handleResult(() =>
            this.actors.daoSystem.initializeTokens()
        );
    }

    async getTokenBalance() {
        return this.actors.daoSystem.getTokenBalance();
    }

    async transferTokens(to: Principal, amount: bigint) {
        return DeResNetUtils.handleResult(() =>
            this.actors.daoSystem.transferTokens(to, amount)
        );
    }

    async createProposal(submission: {
        title: string;
        description: string;
        proposalType: 'grant' | 'review' | 'governance';
        requiredTokens: number;
        duration: number; // in milliseconds
    }) {
        const durationNanos = BigInt(submission.duration * 1000000); // Convert to nanoseconds
        
        return DeResNetUtils.handleResult(() =>
            this.actors.daoSystem.createProposal({
                title: submission.title,
                description: submission.description,
                proposalType: { [submission.proposalType]: null },
                requiredTokens: submission.requiredTokens,
                duration: durationNanos,
            })
        );
    }

    async getProposal(proposalId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.daoSystem.getProposal(proposalId)
        );
    }

    async getAllProposals(page: number = 0, limit: number = 10) {
        return this.actors.daoSystem.getAllProposals({ page, limit });
    }

    async getProposalsByStatus(
        status: 'active' | 'passed' | 'rejected' | 'executed',
        page: number = 0,
        limit: number = 10
    ) {
        return this.actors.daoSystem.getProposalsByStatus(
            { [status]: null },
            { page, limit }
        );
    }

    async vote(proposalId: string, choice: boolean) {
        return DeResNetUtils.handleResult(() =>
            this.actors.daoSystem.vote(proposalId, choice)
        );
    }

    async hasVoted(proposalId: string) {
        return this.actors.daoSystem.hasVoted(proposalId);
    }

    async getUserVotes() {
        return this.actors.daoSystem.getUserVotes();
    }

    async executeProposal(proposalId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.daoSystem.executeProposal(proposalId)
        );
    }

    async getDAOStats() {
        return this.actors.daoSystem.getDAOStats();
    }

    async getTransactionHistory(page: number = 0, limit: number = 10) {
        return this.actors.daoSystem.getTransactionHistory({ page, limit });
    }

    async getUserTransactions(page: number = 0, limit: number = 10) {
        return this.actors.daoSystem.getUserTransactions({ page, limit });
    }
}

// AI Chatbot API wrapper
export class AIChatbotAPI {
    constructor(private actors: CanisterActors) {}

    async createChatSession() {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.createChatSession()
        );
    }

    async getChatSession(sessionId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.getChatSession(sessionId)
        );
    }

    async getUserSessions() {
        return this.actors.aiChatbot.getUserSessions();
    }

    async sendMessage(sessionId: string, content: string, paperRef?: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.sendMessage(
                sessionId,
                content,
                paperRef ? [paperRef] : []
            )
        );
    }

    async analyzePaper(paperId: string, paperContent: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.analyzePaper(paperId, paperContent)
        );
    }

    async getPaperSummary(paperId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.getPaperSummary(paperId)
        );
    }

    async getPaperKeywords(paperId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.getPaperKeywords(paperId)
        );
    }

    async findSimilarPapers(paperId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.findSimilarPapers(paperId)
        );
    }

    async getSimilarPapers(paperId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.getSimilarPapers(paperId)
        );
    }

    async getResearchInsights(topic: string) {
        return this.actors.aiChatbot.getResearchInsights(topic);
    }

    async getChatStats() {
        return this.actors.aiChatbot.getChatStats();
    }

    async deleteChatSession(sessionId: string) {
        return DeResNetUtils.handleResult(() =>
            this.actors.aiChatbot.deleteChatSession(sessionId)
        );
    }
}

// Main API interface
export class DeResNetAPIClient {
    public paperStorage: PaperStorageAPI;
    public dao: DAOSystemAPI;
    public ai: AIChatbotAPI;

    constructor(actors: CanisterActors) {
        this.paperStorage = new PaperStorageAPI(actors);
        this.dao = new DAOSystemAPI(actors);
        this.ai = new AIChatbotAPI(actors);
    }
}

// React hook for using the API
export function useDeResNetAPI() {
    const [api, setAPI] = React.useState<DeResNetAPIClient | null>(null);
    const [isLoading, setIsLoading] = React.useState(true);
    const [error, setError] = React.useState<Error | null>(null);

    React.useEffect(() => {
        deresnetService
            .initialize()
            .then((deresnetAPI) => {
                setAPI(new DeResNetAPIClient(deresnetAPI.actors));
                setIsLoading(false);
            })
            .catch((err) => {
                setError(err);
                setIsLoading(false);
            });
    }, []);

    return { api, isLoading, error };
}